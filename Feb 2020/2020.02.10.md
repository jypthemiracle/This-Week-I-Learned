#  2020.02.10

#  대체 왜 클래스의 필드에 직접 접근하면 안될까?

* 자바의 getter, setter 사용하지 마라고 하는 이유가 궁금했다.

예를 들어보자.

```java
public class VO {
  public String a;
  public String getA() {
    return a;
  }
  public void setA(String a) {
    this.a = a;
  }
}
```

* VO 클래스에서 필드 a에는 setter와 getter가 있다.

* Public 접근자로 선언되어 있기 때문에 외부 클래스에서 접근이 가능하다.

  * 다른 클래스에서 다음과 같이 선언하면 접근이 가능하다.

  ```java
  VO vo = new VO();
  vo.a = "hello"; //변수 a에는 hello가 저장된다.
  ```

* 내가 라이브러리를 만들어 배포하는 사람이라고 가정한다. 자바 사용자는 내가 만든 VO 클래스를 이용하여 vo 객체를 사용하고 싶다.
* 해당 사용자는 vo 객체에 a라는 값을 ```vo.a = "hello"``` 라고 설정할 수도 있지만, ```vo.setA("hello")``` 라고 설정할 수도 있다.
* 이 두 가지 케이스 모두 가능한데, 로직이 동일함에도 불구하고 왜 객체의 필드에 직접 접근하지 마라고 하는 걸까.

* 내가 라이브러리를 만들어 배포하는 사람이라고 다시 가정ㅎ나다. 나는 이 클래스를 활용하여 객체를 생성하는 사용자들이 현재 시간과 본인의 이름, 그리고 뒤에 사용자가 임의로 입력한 String 문자열을 출력할 수 있도록 설계했다.

  * Runclass는 vo 객체가 갖고 있는 String a의 값을 사용자가 넘긴 매개변수 param을 이용하여 지정한다. 현재 시간과 String a를 갖고 있는 VO와 RunClass라는 클래스를 하나 더 만들어 다음과 같이 구현했다고 가정하자.

  ```java
  import java.util.Calendar;
  
  public class RunClass {
    public void setValueA(VO vo, String param) {
      Calendar calendar = Calendar.getInstance();
      vo.setA("TIME: " + calendar.getTime() + "/" + param);
    }
  }
  ```

  * 이렇게 하면 클래스 RunClass와 VO를 활용하여 사용자는 코드를 작성하다가 현재 시간과 자신의 이름을 사용자가 정의한 String에 붙여줄 수 있다.
  * 자, 이렇게 라이브러리를 배포하였고 사용자는 RunClass와 VO 클래스를 이용한다고 가정한다.

* 다음과 같이 출력해본다.

```java
public class Main {
  public static void main(String[] args){
    VO vo = new VO();
    RunClass runClass = new RunClass();
    runClass.setValueA(vo, "aa setting");
    System.out.println(vo.getA()); //Fri Mar 24 .. / aa setting
    
    va.a = "bb";
    System.out.println(vo.getA());
  }
} // bb
```

* RunClass의 클래스와 VO가 라이브러리라고 가정했을 때, 설계자의 의도는 String a라는 값에 사용자가 입력하고자 하는 스트링 값을 현재날짜 + 시간 / 파라미터 로 설정할 수 있는 클래스를 작성한 것이다.
* 사용자가 이 객체의 필드 a에 사용자가 직접 접근할 수 있게 되면 bb가 나오는 참사가 버어진다.
* 객체의 데이터를 마음대로 접근할 수 있다면 메소드를 통해 만들어진 데이터는 의미가 없게 된다.
* 객체에서 데이터는 어떤 메소드의 실행 결과를 누적해서 보존하므로 함부로 누구나 사용하게 해서는 안된다.

### 왜 va.a = "hello" 와 vo.setA("hello") 가 다른가?

* 로직의 문제가 아니다. 사용자의 사용패턴에 대한 문제이다.

* 객체지향은 부품화의 정점이다.
  * 메소드는 부품화의 예시이다. 연관된 로직을 결합해서 메소드라는 완제품을 만들고, 메소드를 부품으로 해서 하나의 완제품인 독립된 객체를 만든다.
  * 프로그램이 커지면 메소드가 많이 생긴다. 따라서 관리하기가 어려워지며, 메소드가 없을 때와 비교했을 때 관리 난이도가 차이가 없게 된다.
  * 따라서 객체지향을 한다. 연관된 메소드와 그 메소드가 사용하는 변수들을 분류하고 그룹핑하는 것이다. 그렇게 그룹핑된 대상이 바로 객체 - 오브젝트이다. 이를 통해 더욱 큰 단위의 부품을 만들 수 있게 된다.
* 부품화는 그룹핑 이상의 무언가이다.
  * 제대로 된 부품이라면 그것이 어떻게 만들어졌는지를 생각하지 않고 사용법만 알아도 잘 사용할 수 있어야 한다.
  * 내부의 동작 방법을 안으로 숨기고, 사용자에게는 사용방법만 노출한다.
  * 부품과 부품을 서로 교환하고 연결할 수 있어야 한다. 모니터가 어떤 모니터인지 신경쓰지 않는다. 일단 연결하는 것이다.
  * 표준에 따라 연결하는 연결점을 우리는 인터페이스라고 부른다. 인터페이스는 부품간의 약속이다.
* 객체의 데이터는 함부로 공개하지 않는다
  * 객체가 가진 데이터에 마음대로 접근해서 편하게 사용할 수 있지만, 객체지향에서는 이를 지양해야 한다.
  * 객체의 데이터를 마음대로 접근할 수 있다면, 메소드를 통해 만들어진 데이터는 의미가 없게 되는 문제가 발생한다.
  * 클래스라는 틀을 이용해서 만드는 객체가 망가지며 객체 사용 의미가 퇴색된다.
  * 객체에서 데이터는 어떤 메소드의 실행 결과를 누적해서 보존하는 경우가 많으므로, 함부로 누구나 사용할 수 있게 해서는 안된다.
  * 객체의 데이터는 메소드를 통해 변경해야 한다. 객체지향 프로그래밍은 필요한 로직이나 기능을 **수행할 수 있는 객체에게 나의 일을 부탁하는** 방식이 되어야 한다.
  * 객체지향에서 객체가 가진 데이터가 필요하다면, 객체에 데이터를 알고 싶다고 **부탁하는** 방식의 프로그래밍이 가장 적합하다.