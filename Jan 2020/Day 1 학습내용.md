# Day 1 학습내용

### 왜 중요한가?

* 컴퓨터는 가산기를 활용하여 사칙연산을 다 해먹기 때문이다.
  * 뺄셈은 감수의 보수를 구하여 더하는 것이고, 곱셈과 나눗셈은 덧셈과 뺄셈 연산의 반복일 뿐이다.

### XOR 게이트

* exclusive OR 게이트의 약자로써, 두 개의 입력신호가 같으면 0을 출력하고 두 개의 입력신호가 다르면 1을 출력한다.
  * exclusive, 즉 '배타적' 이어야 하므로 배타적일 때 1(true)을 출력한다.

### 회로 표기법

![논리회로 기호에 대한 이미지 검색결과](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory2&fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F2724C04454F7DBA2060476)

### 반가산기(half-adder)

* SUM과 CARRY(자리 올림)이 있다.
* SUM은 XOR 게이트를 사용하면 될 것 같다.
* CARRY는 더 쉽다. 둘 다 1일 때만 1이면 된다. 실제로 여기서는 자리올림 비트는 거의 의미가 없다고 볼 수 있다.
* 반 가산기의 목적은 CARRY(올림) 을 추출해 내는데 더 목적이 있다.
* A=1, B=1일 때 CARRY가 1을 출력한다.

### 전가산기(full-adder)

* 반가산기에서 CARRY까지 받아서 올림처리하는 계산회로이다. 
* 현재 자리의 두 비트와 올림자 1개까지 총 3개의 비트를 더해야 한다.
* 반가산기 회로 2개를 이용하여 전가산기를 만든다.
* 1) 이번 연산으로 CARRY가 발생하는가? 2) 이번 연산의 CARRY와 저번 연산의 결과가 더 해져서 CARRY가 발생하는가?
  * 두 경우 모두 어떠한 경우에도 CARRY가 반환되어야 하므로 OR 연산자로 묶이게 된다.

### 참고

* [https://raisonde.tistory.com/entry/%EB%B0%98%EA%B0%80%EC%82%B0%EA%B8%B0Half-adder%EC%99%80-%EC%A0%84%EA%B0%80%EC%82%B0%EA%B8%B0Full-adder](https://raisonde.tistory.com/entry/반가산기Half-adder와-전가산기Full-adder)
* [https://yunsu3042.github.io/devlog/2018/03/08/Half-Adder-Full-Adder-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/](https://yunsu3042.github.io/devlog/2018/03/08/Half-Adder-Full-Adder-쉽게-이해하기/)

### JK's Review 마스터 클래스

https://public.codesquad.kr/jk/cs16-review-day1.pdf

##### #디지털시스템, #논리게이트, #이진법, #진법변환

* 현장에서 요구사항을 마주하면 키워드를 찾아서 스스로 학습해야. 절대로 친절하지 않다.
* 디지털시스템: 디지털을 구현하기 위한 부품으로 만들어져 있음.
  * 왜 이진법? 디지털 시스템은 두 가지 상태(0, 1 or true, false)를 가질 수 있는 부품으로 동작하기 때문임.
  * 논리 게이트, TRUE or FALSE라는 논리식으로 표현되기 마련임.
  * "논리 연산자 만으로도 계산할 수 있다" - 논리 연산자만 가지고 해결하여야 한다 (AND, OR, NOT)
* 숫자는 정수일까, 실수일까... 흠...
* gist를 사용하면 revision을 여러 번 commit한 것처럼 이력을 볼 수 있다.
* 프로그래밍할 때 Type을 왜 사용할까? (좀 의문이었음)
  * 크기?
  * 어떤 값을 다룰 것인지 명확하게 하기 위해?
  * 왜 JS는 타입을 안 쓸까? 타입이 있는데 왜 명시적으로 쓰지 않지? (생각해보니, Swift도 타입추론이 된다고 한다.)
  * 타입은 명시해주는 것이 mistake를 방지할 수 있는 방법이 되더라.
* Boolean과 0, 1은 같은 타입인가? - No. integer로 넘어온다.
  * 타입을 가지고 활용해보려고 노력하고.
* 계산을 하는 데 if문? - 없는 것이 낫더라. 다양한 방법을 학습해보자.
  * true or false 사용하는 것이 낫더라!
  * 계산식을 만드는 것도 좋더라!
* 작은 것부터 만들 때는 큰 것을 활용해서 만들면 된다.
  * TDD: 무엇을 먼저 구현할 지 생각해보기. 밑은 모르겠지만 결과적으로 뭐지? 생각하면서 만드는 사람도 있다.
  * Bottom-up OR Top-down 양자택일적 방법을 모두 고민해야. -> 모두 연습해보면서 시야를 넓혀보아야.
* 논리 연산자와 비트 연산자 모두 같은 결과가 나왔을 것. 
  * boolean type !== bit type(Swift, Java)
* 함수는 동사형으로 쓰는 게 좋아보인다.
  * 하드코딩 대신, 의도를 코드로 표현(ex. 상수를 변수로 미리 선언해둔다던지 - 10비트면 이것이 자주 사용되니 변수화)
  * 좋은 오픈소스 코드를 보면서 메소드 어떻게 정의해뒀는지 보는 것도 좋다.
  * 군더더기 표현(get) 이런 것보다는 명시적인 명사를 변수에 쓰는 것이 좋아보인다.
* 오버플로우는 어떤 경우에 발생하는가? aka. 비트 배열이 가변길이라면 어떻게 구현해야 하지?
  * 배열을 매개변수로 쓸 때 길이가 중요한데, 넘치거나 적으면 어떡하지? 그럴 때 어떻게 동작해야 하지?
    * 예외사항, 다른 경우... 를 의식적으로 고민하도록 하자. -- 요구사항에 없거든. 
      * 이런 케이스 및 경우의 수를 **의식적으로** 찾아내는 연습(귀찮아 하지 말고..)
* LSB/MSB 비트 순서는 구현에 어떤 영향을 주는가
  * LSB 왼쪽이 편하긴 하다고 하더라. 사실 근데 오른쪽은 안해봐서.. **해봐야 한다**.
* 함수 동작을 검증하기 위해서 어떤 과정을 거치는가?
  * 직접 실행
  * 효율적인 방법 고민. 실행해보지 않고도 검증 ...
    * 디버거?
    * 어떻게 테스트 할 거냐? 내가 작성한 로직을 어떻게 검증할거냐?
* 요구사항은 상당히 고수준만 있을텐데, 밑에서 어떻게 쪼개고 + 검증할 지 생각해보는 **의식적인 top-down && bottom-up 연습** 필요.

#디지털시스템 #논리게이트 #이진법 #진법변환