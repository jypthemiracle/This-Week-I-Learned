# 2020.04.11 TIL

## 비트마스크 Bitmask

* 정수의 이진수 표현을 자료 구조로 사용하는 기법
* 더 빠른 시간 O(1) but 원소의 수는 많지 않음
* 간결한 코드와 작은 메모리의 사용

* **유의할 점**
  * 비트가 1이면 “켜져 있다”, 0이면 “꺼져 있다”라고 한다.
  * C++에서는 &,|,^ 등의 비트 연산자의 우선순위는 ==혹은 != 등의 비교연산자 보다 낮다. int c = (6&4 == 4); 의 경우 4==4가 먼저 계산된다. 헷갈리지 않게 항상 괄호를 쓰자.
  * C++에서 N비트 정수를 N비트 이상 왼쪽으로 시프트하면 0이 아니라 오류가 난다.

* **비트마스크를 이용한 집합의 구현**

  비트마스크의 가장 중요한 사용 사례는 집합을 구현하는 것이다. N비트 정수는 **0부터 N-1까지**의 정수 원소를 가질 수 있는 집합이 된다. 원소 i가 집합에 속해 있는지 여부는 2^i을 나타내는 비트가 켜져있는지 여부로 나타낸다. 예를들어 여섯 개의 원소를 갖는 집합 {1,4,5,6,7,9}을 표현하는 이진수는 101111010(2) 이므로 754임을 알 수 있다.

* 비트마스크 연산을 이용해 집합을 조작하는 예제 – 피자집
  * 피자에 0~19번까지 번호를 갖는 스 무가지 토핑을 주문 시 넣기/넣지 않기 선택 할 수 있다.
  * 공집합 : 0
  * 꽉 찬 집합 (스무 개의 토핑을 모두 포함하는 집합) -> 모든 비트가 켜진 숫자

```
// 1<<20은 이진수로 1 뒤에 20개의 0이 있는 정수이다
// 여기서 1을 빼면 20개의 비트가 모두 켜진 수를 얻는다
int fullPizza = (1<<20) -1;
```

* 집합에 원소 추가 (해당 비트를 켠다) -> 가령 페퍼로니 번호가 p(0<p<20)일 때 다음처럼 toppings 집합에 페퍼로니를 추가할 수 있다.

```
/*1을 왼쪽으로 p비트 시프트하면 p번 비트만 켜진 정수가 되므로 
이 값과 toppings를 비트별 OR하면 해당 비트는 반드시 켜지게 된다.
이미 페퍼로니가 들어있어서 1일 경우에는 아무 변동이 없는 셈이다. 
*/
toppings |= (1 << p );
```

- 원소의 삭제 :

```
toppings &= ~(1<<p);
// ~ (1<<p) 은 Not연산을 하므로 해당 비트만 꺼지고 다 켜진 수가 된다.
// 이 수와 &연산을 하므로 나머지 비트는 유지되고 항상 p번 비트는 꺼지게 된다.
```

- 두 집합에 대해 연산하기 : 원소가 아니라 집합 간에도 마찬가지이다.

```
int added = (a | b); //a와 b의 합집합
int intersection = (a & b); ///a와 b의 교집합
int removed = (a & ~b); //a에서 b를 뺀 차집합
int toggled = (a ^ b); //a와 b중에 하나에만 포함된 원소들의 집합
```

* 집합의 크기 구하기 : 비트를 순회하며 켜져있는 비트를 직접 세는 수 밖에 없지만 컴파일러에서 아래와 같은 집합의 크기 구하기 함수를 제공해준다.

```
//gcc,g++
__builtin_popcount(toppings) //toppings는 집합
//visual c++
__popcnt(toppings)
```

- 최소 원소 찾기 : 이 정수의 이진수 표현에서 끝에 붙어 있는 0이 몇 개인가? 40이 주어질 경우 3을 구함

```
//gcc,g++
__builtin_ctz(toppings) //toppings는 집합
//visual c++
__BitScanForward(&index,toppings)
```

- 최소 원소 비트 찾기 : 이 경우 40이 주어질 경우 2^3을 구함

```
//2의 보수를 사용한다는 점을 이용
int firstTopping = (toppings & -toppings);
```

- 최소 원소 지우기 :

```
toppings &= (toppings -1);
//toppings-1의 이진수 표현은 toppings에서 켜져 있는 최하위 비트를 끄고 그 밑으 비트들을 전부 켠 것이다.
//따라서 두 값을 AND연산하면 최하위 비트와 그 이하 비트들 모두 0이 된다. 
```

- 모든 부분 집합 순회하기 :

```
for(int subset = pizza; subset ; subset = ((subset-1) & pizza)){
//subset은 pizza의 부분집합
}
```