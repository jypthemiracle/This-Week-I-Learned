## 2020.01.28 TIL

오늘의 CS16 Day 14 문제는 정규표현식의 연장선상 -_- 따라서 2 consecutive days 연속으로 정규표현식과 함께 싸우게 되었다.

### FILE URL Scheme

* File의 URL 표현기준은 RFC 8089라는 표준에서 나오게 되었다. 대략적으로는 이렇다고 한다.

```
file://host/path
```

* host는 자기 자신일 때, 즉 localhost일 때 생략이 가능하다고 한다.
  * 단, 슬래시는 생략해서는 안된다고 한다. ```file:///foo.txt``` 이런 식이다.
* URL은 Protocol, Domain Name, Port, Path to the file, Parameters, Anchor로 나뉘어져 있다.

### 정규표현식 패턴

정규표현식은 그 자체로 참 어려운 것 같고, 여러 가지 학습할 사항은 많은 것 같지만.. 천천히 정리해보도록 하자.

정규표현식을 사용하는 방법은 언어별로 모두 다르지만, 정규식 패턴은 아주 사소한 차이를 제외하고 다 비슷한 것으로 알려져 있다. 주요 내용을 아래에 정리해본다.

| 정규식 패턴 | 설명                                                         |
| ----------- | ------------------------------------------------------------ |
| `^`         | 줄(Line)의 시작에서 일치, `/^abc/`                           |
| `$`         | 줄(Line)의 끝에서 일치, `/xyz$/`                             |
| `.`         | 임의의 한 문자와 일치                                        |
| `a|b`       | a 또는 b와 일치, 인덱스가 작은 것을 우선 반환                |
| `*`         | 0회 이상 연속으로 반복되는 문자와 가능한 많이 일치, `{0,}`와 동일 |
| `*?`        | 0회 이상 연속으로 반복되는 문자와 가능한 적게 일치(lazy), `{0}`와 동일 |
| `+`         | 1회 이상 연속으로 반복되는 문자에 가능한 많이 일치, `{1,}`와 동일 |
| `+?`        | 1회 이상 연속으로 반복되는 문자에 가능한 적게 일치(lazy), `{1}`와 동일 |
| `?`         | 없거나 1회 가능한 많이 일치                                  |
| `??`        | 없거나 1회 가능한 적게 일치(lazy)                            |
| `{3}`       | 3(숫자)개 연속 일치                                          |
| `{3,}`      | 3개 이상 연속 일치                                           |
| `{3,5}`     | 3개 이상 5개 이하(3~5개) 연속 일치                           |
| `{3,5}?`    | 3개 이상 5개 이하(3~5개) 연속 중 가능한 적은 3개 연속 일치(lazy), `{3}`와 동일 |
| `()`        | 캡처(Capture)할 그룹                                         |
| `(?<>)`     | 캡처 그룹 이름 지정, `/(?<name>pattern)/` **ES2018**         |
| `\1~9`      | 정규식 내 캡처된 값 참조, `/(abc)\1/`                        |
| `(?:)`      | 캡처(Capture)하지 않는 그룹                                  |
| `(?=)`      | 앞쪽 일치(Lookahead), `/ab(?=c)/`                            |
| `(?!)`      | 부정 앞쪽 일치(Negative Lookahead), `/ab(?!c)/`              |
| `(?<=)`     | 뒤쪽 일치(Lookbehind), `/(?<=ab)c/` **ES2018**               |
| `(?<!)`     | 부정 뒤쪽 일치(Negative Lookbehind), `/(?<!ab)c/` **ES2018** |
| `[abc]`     | a 또는 b 또는 c와 일치, 점(`.`)이나 별표(`*`) 같은 특수 문자는 `[]`안에서 특수 문자가 아님, `/\.[.]/` |
| `[a-z]`     | a부터 z 사이의 문자 구간에 일치(영어 소문자)                 |
| `[A-Z]`     | A부터 Z 사이의 문자 구간에 일치(영어 대문자)                 |
| `[0-9]`     | 0부터 9 사이의 문자 구간에 일치(숫자)                        |
| `[가-힣]`   | 가부터 힣 사이의 문자 구간에 일치(한글)                      |
| `[2-7]`     | 2부터 7 사이의 문자 구간에 일치(2,3,4,5,6,7)                 |
| `[b-f]`     | b부터 f 사이의 문자 구간에 일치(b,c,d,e,f)                   |
| `[다-바]`   | 다부터 바 사이의 문자 구간에 일치(다,라,마,바)               |
| `[^abc]`    | a 또는 b 또는 c가 아닌 나머지 문자에 일치(부정)              |
| `\`         | 이스케이프 문자, `/\.\?\/\$\^/`                              |
| `\b`        | 63개 문자(영문 대소문자 52개 + 숫자 10개 + `_`(underscore))가 아닌 나머지 문자에 일치하는 경계(boundary) |
| `\B`        | 63개 문자에 일치하는 경계                                    |
| `\d`        | 숫자(Digit)에 일치                                           |
| `\D`        | 숫자가 아닌 문자에 일치                                      |
| `\p{}`      | 유니코드 속성(Property) 집합에 맞는 문자에 일치, `/\p{Emoji}/u` **ES2018** |
| `\P{}`      | 유니코드 속성 집합에 맞지 않는 문자에 일치, `/\p{Uppercase}/u` **ES2018** |
| `\s`        | 공백(Space, Tab 등)에 일치                                   |
| `\S`        | 공백이 아닌 문자에 일치                                      |
| `\w`        | 63개 문자(Word, 영문 대소문자 52개 + 숫자 10개 + `_`)에 일치 |
| `\W`        | 63개 문자가 아닌 나머지 문자에 일치                          |
| `\x`        | 16진수 문자에 일치, `/\x61/`는 `a`에 일치                    |
| `\0`        | 8진수 문자에 일치, `/\141/`은 `a`에 일치                     |
| `\u`        | 유니코드(Unicode) 문자에 일치, `/\u0061/`는 `a`에 일치       |
| `\c`        | 제어(Control) 문자에 일치                                    |
| `\f`        | 폼 피드(FF, U+000C) 문자에 일치                              |
| `\n`        | 줄 바꿈(LF, U+000A) 문자에 일치                              |
| `\r`        | 캐리지 리턴(CR, U+000D) 문자에 일치                          |
| `\t`        | 탭 (U+0009) 문자에 일치                                      |
| `$``        | 문자 대체(replace) 시 일치한 문자 이전 값 참조               |
| `$'`        | 문자 대체(replace) 시 일치한 문자 이후 값 참조               |
| `$+`        | 문자 대체(replace) 시 마지막으로 캡처된 값 참조              |
| `$&`        | 문자 대체(replace) 시 일치한 문자 결과 전체 참조             |
| `$_`        | 문자 대체(replace) 시 입력(input)된 문자 전체 참조           |
| `$1~9`      | 문자 대체(replace) 시 캡처(Capture)된 값 참조                |

* 플래그라는 것도 있다.

| 플래그 | 설명                                                      |
| ------ | --------------------------------------------------------- |
| `g`    | 모든 문자와 여러 줄 일치(global)                          |
| `i`    | 영어 대소문자를 구분 않고 일치(insensitive, ignore case)  |
| `m`    | 여러 줄 일치(multi line)                                  |
| `u`    | 유니코드(unicode)                                         |
| `y`    | `lastIndex` 속성으로 지정된 인덱스에서만 1회 일치(sticky) |

* 좋은 사이트 몇 개를 첨부해본다.
  * https://regex101.com/ JK가 추천해줬다. 표현식을 넣고 테스트해볼 수 있다.
  * https://regexper.com/ 정규식 패턴을 그림으로 표현해주는 곳이다.
* 정규식 패턴을 그림으로 표현해보면 다음과 같다.

![정규식 도식에 대한 이미지 검색결과](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory2&fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F22C9C733596DC89007BCC2)

### 패턴 01. 줄의 시작에서 일치

* `^`는 Line의 시작 지점을 의미합니다.

```
/^lorem/gi
```

* (시작 지점) 다음에 `"lorem"`이라는 문자가 있는 패턴을 검색하라는 표현식입니다.
  플래그 `g`와 `i`를 사용했기 때문에 문자열 전역에서 대소문자 구분 없이 검색합니다.
  다음과 같은 결과가 나옵니다.

### 패턴 02. 줄의 끝에서 일치

- `$`는 Line의 끝 지점을 의미합니다.

```/ipsum\.$/gi```

> 특수 문자 앞에 위치한 백슬래시는 ‘다음에 나오는 문자는 특별하지 않고 문자 그대로 해석되어야 한다.’는 사실을 가리킵니다.

### 패턴 03. 임의의 한 문자와 일치

```/./gi```

`.`은 임의의 한 문자를 의미하기 때문에 모든 문자(특수기호, 띄어쓰기 등 포함)가 선택됩니다.

```
/r./gi
```

`"r"`로 시작하며 임의의 한 문자를 포함하는 총 2개의 문자(2글자)가 플래그 `g`로 인해 모두 검색됩니다.

### 패턴 04. a|b (a 또는 b와 일치)

‘or’(또는) 조건으로 검색합니다.
`a|b`는 ‘a’도 검색하고 ‘b’도 검색합니다.

```/of|te/gi```

플래그 `g`가 없어 전역 검색이 아니기 때문에 검색된 결과의 인덱스가 가장 작은 값(가장 앞서 일치한)을 반환합니다.

```/of\te```

### 패턴 05. 0회 이상 연속으로 반복되는 문자와 가능한 많이 일치

```/ing*/gi```

`"in"`을 검색하고 `"g"`는 0회 이상 연속으로 반복되는 문자와 가능한 많이 일치시킵니다.
즉 `"g"`는 0회 포함되거나(포함되지 않거나) 연속으로 몇 번을 반복 포함하나 검색이 됩니다.

![RegExp](https://heropy.blog/images/screenshot/regex101.com_screenshot_8.jpg)

### 패턴 06. 0회 이상 연속으로 반복되는 문자와 가능한 적게 일치

```
/pass*/gi
```

`*`는 가능한 많이 일치하기 위해서 `"pas"`에 0회 이상 일치하는 `"s"`를 포함해서 검색합니다. `"pass"`가 검색됩니다.

```
/pass*?/gi
```

하지만 패턴 `*?`는 가능한 적게 일치하기 위해서 `"pas"`에 0회 이상 일치하는 `"s"`를 포함하지 않습니다. 따라서 `"pas"`가 검색됩니다.

### 패턴 07. 1회 이상 연속으로 반복되는 문자에 가능한 많이 일치

패턴 `*`의 경우 일치하는 문자를 포함하지 않아도(0회 이상) 검색이 되었습니다.
하지만 `+`의 경우 일치하는 문자를 포함해야(1회 이상) 합니다.

```
/dum*/gi
```

이렇게 하면 ```du```도 검색이 됩니다.

```
/dum+/gi
```

이렇게 하면 ```du```에서 ```m```이 1개 이상 포함된 문자를 검색합니다.

### 패턴 08. 1회 이상 연속으로 반복되는 문자에 가능한 적게 일치

```
/dum+?/gi
```

`"m"`이 1개 이상 포함하지만 가장 적게 일치하는 문자를 검색합니다.

예를 들어 텍스트 전체를 통틀어 ```dum```이 있는 경우 ```dum```만 출력하고, ```dumm```만 있는 경우 ```dumm```만 출력합니다.

### 패턴 09. 없거나 1회 가능한 많이 일치

```
/ble?/gi
```

`"bl"`을 검색하고 `"e"`는 없거나(포함하지 않거나) 1회(1번만 포함하는) 일치하는 문자를 검색합니다. 가능한 많이 일치하려고 하므로 `"e"`를 포함하여 일치합니다.

### 패턴 10. 없거나 1회 가능한 적게 일치

```
/ble??/gi
```

가능한 적게 일치하려고 한다면 `"e"`를 포함하지 않으려고 합니다.

### 패턴 11. 연속 일치

패턴 `{}`은 위에서 봤던 패턴 `*`, `*?`, `+`, `+?`의 확장판으로 생각하시면 쉽습니다.
‘0개 이상’, ‘1개 이상’이 전부인 위 방식과 다르게 직접 숫자를 넣어서 연속되는 개수를 설정할 수 있습니다.

| 정규식 패턴 | 설명                                                         |
| ----------- | ------------------------------------------------------------ |
| `*`         | 0회 이상 연속으로 반복되는 문자와 가능한 많이 일치, `{0,}`와 동일 |
| `*?`        | 0회 이상 연속으로 반복되는 문자와 가능한 적게 일치(lazy), `{0}`와 동일 |
| `+`         | 1회 이상 연속으로 반복되는 문자에 가능한 많이 일치, `{1,}`와 동일 |
| `+?`        | 1회 이상 연속으로 반복되는 문자에 가능한 적게 일치(lazy), `{1}`와 동일 |
| `{3}`       | 3(숫자)개 연속 일치                                          |
| `{3,}`      | 3개 이상 연속 일치                                           |
| `{3,5}`     | 3개 이상 5개 이하(3~5개) 연속 일치                           |
| `{3,5}?`    | 3개 이상 5개 이하(3~5개) 연속 중 가능한 적은 3개 연속 일치(lazy), `{3}`와 동일 |

### 패턴 12. 캡처할 그룹

#### 그룹화

표현식의 일부를 패턴 `()`로 묶어주어 그 안의 내용을 하나의 결과로 그룹화합니다.

* 표현식 `ko+`는 `"k"`를 검색하고 `"o"`를 1회 이상 연속으로 반복되는 문자로 검색합니다. 그 결과로 `"koooo"`가 반환되었습니다.

* 하지만 표현식 `(ko)+`는 `"k"`와 `"o"`를 묶었기(그룹화) 때문에 `"ko"`를 1회 이상 연속으로 반복되는 문자로 검색합니다. 따라서 결과가 `"kokokoko"`가 반환되었습니다.
* 패턴 `()`는 괄호 안에 있는 표현식을 캡처하여 사용합니다. 캡처는 밖에서 안으로, 왼쪽에서 오른쪽으로 순으로 이루어 집니다.

### 패턴 13. 캡처하지 않는 그룹

캡처 그룹 패턴 `()`는 그룹화 외 캡처 같은 여러 의미를 가지기 때문에 생각보다 다루기 어려울 수 있습니다. 그래서 표현식의 그룹화 의미만 가지는 패턴 `(?:)`를 사용할 수 있습니다.

### 패턴 14. 앞쪽 일치

패턴 `(?=)`은 그 앞에 위치하는 표현식이 패턴 내 표현식(`(?=여기)`)에 일치하는 문자의 앞에 있어야 함을 의미합니다.

다음 예제에서 어떻게 사용하는 지 살펴봅시다.

```
http://www.forta.com
https://mail.forta.com
ftp://ftp.forta.com

//정규표현식
.+(?=:)

//결과
http:
https:
ftp:
```

```
http://www.forta.com
https://mail.forta.com
ftp://ftp.forta.com

//정규표현식
.+(:)

//결과
http
https
ftp
```



다음 예제는 패턴 `(?=)`의 앞에 위치하는 표현식 `ab`가 패턴 내 표현식 `c`의 앞에 있기 때문에 결과로 `"ab"`를 반환합니다. 여기서 `(?=c)`은 그 앞에 위치하는 표현식을 검색하기 위한 조건일 뿐입니다.
즉, `"ab"`를 검색하되 그다음에 `"c"`가 있어야만 일치한다는 의미가 됩니다.

```
"abc".match(/ab(?=c)/);
// ["ab", index: 0, input: "abc", groups: undefined]

"abd".match(/ab(?=c)/);
// null
```

‘앞쪽 일치’라는 단어처럼 패턴의 앞에 있는 표현식을 검색하는 것이기 때문에 순서를 바꾸면 전혀 다른 결과가 반환됩니다. 다음 첫 번째 예제는 패턴 내 표현식 `c` 앞에 `""`(빈 문자열)을 일치한 후 `"ab"`를 검색하기 때문에 일치하는 결과가 없게 됩니다.

```
"abc".match(/(?=c)ab/);
// null

"abc".match(/(?=c)/);
// ["", index: 2, input: "abc", groups: undefined]
`
```

### 패턴 15. 부정 앞쪽 일치

패턴 `(?!)`는 패턴 `(?=)`의 부정의 의미를 가집니다.

```
"abc".match(/ab(?!c)/);
// null

"abd".match(/ab(?!c)/);
// ["ab", index: 0, input: "abd", groups: undefined]
```

### 패턴 16. 뒤쪽 일치

패턴 `(?<=)`은 그 뒤에 위치하는 표현식이 패턴 내 표현식에 일치하는 문자의 뒤에 있어야 함을 의미합니다. ‘앞쪽 일치(`(?=)`)’에 대해서 이해했다면 어렵지 않을 것입니다.

```
ABC01: $23.45
HGG42: $5.31
CFMX1: $899.00
XTC99: $69.96
Total items found: 4

//정규 표현식
(?<=\$)[0-9.]+

//결과
23.45
5.31
899.00
69.96
```



```
"xyz".match(/(?<=x)yz/);
// ["yz", index: 1, input: "xyz", groups: undefined]

"ayz".match(/(?<=x)yz/);
// null
```

### 패턴 17. 부정 뒤쪽 일치

패턴 `(?<!)`는 패턴 `(?<=)`의 부정의 의미를 가집니다.

```
"xyz".match(/(?<!x)yz/);
// null

"ayz".match(/(?<!x)yz/);
// ["yz", index: 1, input: "ayz", groups: undefined]
```

### 패턴 18. a 또는 b 또는 c와 일치

패턴 `[]` 안에 있는 문자는 각각 ‘or’(또는)의 의미를 가집니다. 따라서 앞서 살펴봤던 것처럼 표현식 `[abc]`는 `a|b|c`와 같습니다.

#### 문자 범위 지정

패턴 `[]` 안에서 `-`을 이용하면 문자의 범위(구간)를 지정할 수 있습니다.

### 패턴 19. a 또는 b 또는 c가 아닌 나머지 문자에 일치

패턴 `[^]`는 패턴 `[]`의 반대(부정) 의미를 가집니다. 표현식 `[^abc]`는 `a|b|c`를 제외한 나머지 문자를 검색합니다.

### 패턴 20. if-else 조건문 활용하기

Java의 클래스 단위에서 지원하는 ```if-else``` 구문이 있다.

```
((?<=if )then)|((?<!if )end)
```

```
The conditional constructs (?(condition)X) and (?(condition)X|Y).
```

### 미션 풀이하기

다음과 같은 링크에 대한 정규식 해답은 다음과 같다.

```
http://user_name:pass-word@boostcamp.connect-foundation.or.kr:2019/first/second/last?query=ab&param=12

(?:([^\\:]*)\\:\\/\\/)?(?:([^\\:\\@]*)(?:\\:([^\\@]*))?\\@)?(?:([^\\/\\:]*))?(?:\\:([0-9]*))?\\/(\\/[^\\?#]*(?=.*?\\/)\\/)?([^\\?#]*)?(?:\\?([^#]*))?(?:#(.*))?
```

솔직히 말하면 인터넷에서 퍼 왔고, 아직 무슨 소리인지 잘 모르겠다. 하나 씩 떼어가보며 학습하기로..

### Appendix

https://heropy.blog/2018/10/28/regexp/

https://stackoverflow.com/questions/27745/getting-parts-of-a-url-regex

https://stackoverflow.com/questions/12691404/understanding-regex-if-then-statements