# [Graph] 인접 행렬과 인접 리스트

## 인접 행렬: 노드 간의 관계를 저장
### 정의
* 그래프의 연결 관계를 이차원 배열로 나타낸다. 예를 들어 인접 행렬을 ```adj[][]``` 라고 한다면, ```adj[i][j]```에 대하여 다음과 같이 나타낼 수 있다.

> adj[i][j]: 노드 i에서 노드 j까지 가는 간선이 있으면 1(또는 간선의 가중치) 아니면 0

### 예시
* 예를 들어, 다음과 같은 그래프가 있을 때 그래프의 연결 관계를 인접 행렬로 나타내보도록 하자.

![](https://i.imgur.com/OvCKCOZ.png)
* 노드 i에서 노드 j로 가는 간선이 있다는 뜻은 노드 j에서 노드 i로 가는 간선이 존재한다는 의미이다.
* 따라서, 인접 행렬이 대각성분 - 즉 ```adj[i][j]```에서 ```i, j```가 같은 원소들을 기준으로 대칭을 갖는다.
* 만약 방향이 없는 무향 그래프라면 다음과 같이 될 터이다.

![](https://i.imgur.com/vlKACtF.png)

### 장점과 단점
* 장점: 구현이 쉽다는 장점이 있다.
    * 플로이드-워셜 알고리즘은 모든 노드에서 다른 노드로 가는 최소 비용을 V^2 크기의 2차원 리스트에 저장한 다음에 해당 비용을 갱신해서 최단 거리를 계산했다.
    * 노드 i와 노드 j가 연결되어 있는 지 확인하고 싶을 때에는, ```adj[i][j]```가 1인지, 아니면 0인지만 확인하면 되므로 ```O(1)```의 시간 복잡도를 갖는다.
* 단점: 많은 메모리 공간이 필요하다.
    * 전체 노드의 개수가 V이고 간선의 개수가 E일 때, 간선 정보를 저장하기 위하여 O(V^2) 만큼의 메모리 공간이 필요하다.
    * 노드 i에 연결된 모든 노드를 방문하고 싶다면, ```adj[i][1]```부터 ```adj[i][V]```를 모두 확인해보아야 하므로 O(V)의 시간이 걸린다.
    * 간선의 비용을 알고 싶을 때 많은 시간이 걸린다.

### 구현
* 노드의 개수와 간선의 개수를 입력받는다.
* 간선의 개수만큼 for문을 돌면서 양 끝 노드를 입력받는다.

## 인접 리스트: 간선 정보를 저장
### 정의
* 인접 리스트는 그래프의 연결 관계를 배열로 나타내는 방식이다.

> adj[i] : 노드 i에 연결된 노드를 원소로 갖는 벡터이다. 만약 간선에 가중치가 있다면, C++ 기준으로 pair<int, int>로 표기한다.

### 예시
![](https://i.imgur.com/iz7ho71.png)
* 여기서 adj[1]의 벡터는 총 3개의 성분을 갖게 된다. 각각의 성분에 접근하기 위해서는 ```adj[1][0] = 2```와 같은 방식을 이용하면 된다.
* 인접 리스트에서 ```adj[1]```에 있는 세 노드의 순서는 의미가 없다. 관습적으로 낮은 숫자의 노드를 먼저 표기한다.

### 장점과 단점
* 장점
    * 실제 연결된 노드의 정보만 저장
    * 모든 벡터의 원소의 개수의 합이 간선의 개수와 같다. 간선의 개수에 비례하는 메모리만 차지한다.
    * 노드 2와 연결된 모든 노드를 방문하고 싶을 때, 인접 리스트는 실제 연결된 노드를 확인해볼 수 있으므로 ```adj[2][0] 부터 adj[2][adj[2].size()-1]```로 1번 방문한다.
    * 노드가 V개 있고, 간선이 E개 있을 때 인접 행렬은 모든 노드에 연결된 노드를 방문하고 싶다면 전체 노드를 방문해야 하므로 O(V^2)의 시간이 걸리지만, 인접 리스트는 각 노드마다 연결된 간선만 확인할 수 있으므로 전체 간선의 개수만큼 확인할 수 있다. 따라서 O(E)의 시간 복잡도를 가진다.

* 단점
    * 노드 i와 노드 j가 연결 되었는지 알기 위해서는 ```adj[i]```의 벡터 성분을 전부 순회하면서 확인해야 한다. 따라서 시간 복잡도가 ```O(V)```가 된다. 하지만 인접 행렬은 ```adj[i][v]```이므로 O(1)의 시간 복잡도를 갖는다.
